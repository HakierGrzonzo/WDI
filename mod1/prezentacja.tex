\documentclass{beamer}
	\usepackage{inputenc}[utf8]
	\usepackage{mdframed}
	\usepackage{graphicx}
	\usepackage{amsmath}
	\usepackage{amsfonts}
    \usepackage{polski}
    \usepackage[polish]{babel} 
    \usepackage{indentfirst}
    \usepackage{icomma}
    \usepackage{minted}
    \usepackage{ragged2e}
    \brokenpenalty=1000
    \clubpenalty=1000
    \widowpenalty=1000    
    \apptocmd{\frame}{}{\justifying}{} % Allow optional arguments after frame.
    \newcommand{\obrazek}[2]{
        \begin{figure}[h]
            \centering
            \includegraphics[scale=#1]{#2}
        \end{figure}
    }     
            
    
    \newcommand{\twierdzonko}[1]{
        \begin{center}
        \begin{mdframed}
        #1
        \end{mdframed}          
        \end{center}
    } 
    \usetheme{Warsaw}
    \title{Algorytmy}
    \author{Grzegorz Koperwas \and Mateusz Randak \and Piotr Kołodziejski}
    \date{\today}

\begin{document}
    \begin{frame}
        \titlepage
    \end{frame}
    \section{Czym jest algorytm?}
    \begin{frame}
        \frametitle{Czym jest algorytm?}
        \begin{block}{Definicja}
            \emph{Algorytm} to zestaw instrukcji opisujących krok po kroku jak wykonać pewne zadanie.   
        \end{block}
        Mamy z nimi do czynienia w codziennym życiu wykonując różne czynności według pewnych schematów. Przykładowo gdy gotujemy i podążamy za pewnym przepisem.

        Algorytmy odgrywają niezwykle ważną rolę w informatyce. Są one potrzebne do optymalizacji oprogramowania, tak aby działało jak najefektywniej. Specyficznnym rodzajem algorytmów są algorytmy rekurencyjne. 

        \begin{block}{Definicja}
            \emph{Rekurencja} polega na odwołaniu się funkcji do samej siebie.
        \end{block}
    \end{frame}
    \section{Wyszukiwanie binarne}
    \begin{frame}
        \frametitle{Wyszukiwanie binarne:}
        \emph{Wyszukiwanie binarne} - algorytm stosowany do wyszukiwania
        elementów w posegregowanych zbiorach. Cechuje się złożonością czasową $O \left(\log_2 n \right)$, podczas gdy wyszukiwanie liniowe (element po elemencie), ma złożoność $O \left( n \right)$.
    \end{frame}
    \begin{frame}
        \frametitle{Zasada działania}
        Główną ideą wyszukiwania binarnego jest podział elementów w przeszukiwanym uporządkowanym zbiorze danych
        (np. tablicy) na coraz to mniejsze zbiory, tak by optymalnie ograniczyć zakres poszukiwania.
        Należy zaznaczyć, że elementy muszą być ze sobą \emph{porównywalne}, tzn. spośrod dowolnych dwóch elementów
        da się wyłonić większy i mniejszy (ew.~równy), np. po wartości lub nazwie.

        \begin{enumerate}
            \item gdy środkowy element jest mniejszy od szukanej, za dolną granicę uznaje się kolejny element, a górna pozostaje bez zmian
            \item gdy środkowy element jest większy od szukanej, za górną granicę uznaje się poprzedni element,
            a dolna pozostaje bez zmian
        \end{enumerate}

        Następnie powyższe kroki zostają powtórzone. Jeżeli element nie zostanie znaleziony,
        zwracana jest odpowiednia wartość wskazująca na błąd (np. $-1$ lub $null$).
    \end{frame}
    \begin{minted}[fontsize=\small]{python}
# searches for specified item in chosen collection
def binary_search(item, collection):
    lower_bound = 0
    upper_bound = len(collection) - 1

    while lower_bound <= upper_bound:
        mid = (lower_bound + upper_bound) // 2

        if collection[mid] == item:
            return mid

        if collection[mid] < item:
            lower_bound = mid + 1
        else:
            upper_bound = mid - 1

    # if item not found
    raise Exception("not found")
    \end{minted}
    \section{Quicksort}
    \begin{frame}
        \frametitle{Quicksort:}
            Quicksort to rekurencyjny algorytm sortujący, działający poprzez dzielenie początkowego zbioru na coraz mniejsze podzbiory. 
            \vspace{5mm}

            Działanie:
            \begin{enumerate}
                \item Wybierz element z \emph{danego zbioru}, zwany \emph{elementem rozdzielajączym.}
                \item Elementy mniejsze od \emph{elementu rozdzielającego} przenieś do zbioru $A$, większe do $C$, a równe do $B$.
                \item Posortuj zbiory $A$ i $C$ quicksortem.
                \item Wynikiem jest połączenie zbiorów $A + B + C$.
            \end{enumerate}
    \end{frame}
    \begin{minted}[fontsize=\small]{python}
def quicksort(zbiór):
    if len(zbiór) <= 1:
        # nie trzeba sortować zbiorów pustych 
        return zbiór
    else:
        element_rozdzielający = zbiór[0]
        a = list() # większe
        b = list() # równe
        c = list() # mniejsze
        for element in zbiór:
            if element < element_rozdzielający:
                a.append(element)
            elif element > element_rozdzielający:
                c.append(element)
            else:
                b.append(element)
        a = quicksort(a)
        c = quicksort(c)
        return a + b + c
        
    \end{minted}
\end{document}